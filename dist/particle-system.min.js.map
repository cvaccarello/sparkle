{"version":3,"sources":["particle-system.min.js","Particle.js","ParticleEmitter.js","ParticleSystem.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","Particle","spawn_point","direction","cfg","arguments","undefined","debug","ctx","this","_settings","$","extend","append_to","template","time_to_live","speed_amt","size_amt","size","$element","css","appendTo","width","height","local_coords","offsetParent","offset","coordinates","x","left","y","top","_debug","_vx","Math","cos","_vy","sin","_ttl","position","visibility","_render","value","elapsed_time","reduceTTL","move","remove","fillStyle","beginPath","arc","PI","closePath","fill","transform","get","_typeof","Symbol","iterator","obj","constructor","ParticleEmitter","radians","active","element","max_particles","emit_delay","min","max","particle","particles","outerWidth","outerHeight","is","getContext","_active","_destroyed","_triggerCallback","_spawn_position","_delay","_time","Date","_elapsed_time","getTime","right","up","down","now","console","log","_createParticles","_updateParticles","location","random","push","amount","callback","_this","window","setTimeout","call","clearTimeout","splice","clearRect","p","update","TTL","particleSpawnPosition","delay_settings","addParticle","round","ParticleSystem","timeout","_particle_emitters","requestAnimationFrame","_update","setInterval","Emitter","isDestroyed"],"mappings":"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","file":"particle-system.min.js","sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*****************************************************************************************************/\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Description:  A Particle class for controlling how a single particle behaves\t\t\t\t\t**/\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/*****************************************************************************************************/\n\n/**\r\n * Particle class\r\n */\nvar Particle = function () {\n\n\t/**\r\n  * Create a Particle object\r\n  * @param {Object} spawn_point - x, y spawn point of particle\r\n  * @param {Number} spawn_point.x\r\n  * @param {Number} spawn_point.y\r\n  * @param {Number} direction - direction to move particle in radians\r\n  * @param {Object} cfg - default particle settings\r\n \t * @property {jQuery} cfg.append_to - element to append particles to\r\n \t * @property {String} cfg.template - an html string template to create particles with\r\n \t * @property {Number} cfg.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.speed - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.size - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n  * @param {Boolean} [debug]\r\n  * @param {DOM} [ctx] - context of canvas element\r\n  * @constructor\r\n  */\n\tfunction Particle(spawn_point, direction) {\n\t\tvar cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\tvar debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\tvar ctx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n\t\t_classCallCheck(this, Particle);\n\n\t\t// setup default settings, given configuration\n\t\tthis._settings = $.extend(true, {\n\t\t\tappend_to: $('body'),\n\t\t\ttemplate: '<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>',\n\t\t\ttime_to_live: 2000,\n\t\t\tspeed_amt: 10,\n\t\t\tsize_amt: 0,\n\t\t\tsize: 10\n\t\t}, cfg);\n\n\t\tif (!ctx) {\n\t\t\t// create a DOM object given a template, and hide so that it has dimension, but can't be seen until positioned\n\t\t\tthis.$element = $(this._settings.template).css('visibility', 'hidden');\n\n\t\t\t// append particle element to an element on the page\n\t\t\tthis.$element.appendTo(this._settings.append_to);\n\n\t\t\t// get width and height of element for positioning purposes\n\t\t\tthis.width = this.$element.width();\n\t\t\tthis.height = this.$element.height();\n\t\t}\n\n\t\t// convert the global spawn_point coordinates into their appropriate local coordinates (based off the closest positioned parent)\n\t\tvar local_coords = this.$element ? this.$element.offsetParent().offset() : this._settings.append_to.offset();\n\n\t\tthis.coordinates = { x: spawn_point.x - local_coords.left, y: spawn_point.y - local_coords.top };\n\n\t\tthis.size_amt = this._settings.size_amt;\n\t\tthis.speed_amt = this._settings.speed_amt;\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// for debugging purposes (used for console logging)\n\t\tthis._debug = debug;\n\n\t\t// OPTIMIZATION: velocity/movement amount based on speed and direction\n\t\tthis._vx = this.speed_amt * Math.cos(direction);\n\t\tthis._vy = this.speed_amt * -Math.sin(direction);\n\n\t\t// how long the particle will exist before it's removal\n\t\tthis._ttl = this._settings.time_to_live;\n\n\t\t// store reference to context of canvas elements\n\t\tthis.ctx = ctx;\n\n\t\t// default size of canvas particles\n\t\tthis.size = this._settings.size;\n\n\t\t/*********************************************************************************\r\n  **  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\tif (!ctx) {\n\t\t\t// set visibility so that the particle can now be seen (it was hidden until position calculations were complete)\n\t\t\tthis.$element.css({\n\t\t\t\t'position': 'absolute',\n\t\t\t\t'visibility': 'visible'\n\t\t\t});\n\t\t}\n\n\t\t// render the particle\n\t\tthis._render();\n\t}\n\n\t_createClass(Particle, [{\n\t\tkey: 'update',\n\n\n\t\t/**\r\n   * @param {Number} elapsed_time - how long since the emitter/particle was last updated\r\n   */\n\t\tvalue: function update(elapsed_time) {\n\t\t\t// adjust particles time to live value (life time)\n\t\t\tthis.reduceTTL(elapsed_time);\n\n\t\t\t// adjust particles coordinates\n\t\t\tthis.move(elapsed_time);\n\n\t\t\t// adjust width & height based on size increase/decrease setting\n\t\t\tthis.width += this.size_amt * elapsed_time;\n\t\t\tthis.height += this.size_amt * elapsed_time;\n\n\t\t\t// render element (update in dom)\n\t\t\tthis._render();\n\t\t}\n\t}, {\n\t\tkey: 'reduceTTL',\n\n\n\t\t/**\r\n   * Reduce the particles life based on elapsed time\r\n   * @param elapsed_time\r\n   */\n\t\tvalue: function reduceTTL(elapsed_time) {\n\t\t\tthis._ttl -= elapsed_time;\n\t\t}\n\t}, {\n\t\tkey: 'move',\n\n\n\t\t/**\r\n   * Move particle based on speed, direction, and time since last update\r\n   * @param elapsed_time\r\n   */\n\t\tvalue: function move(elapsed_time) {\n\t\t\tthis.coordinates.x += this._vx * elapsed_time;\n\t\t\tthis.coordinates.y += this._vy * elapsed_time;\n\t\t}\n\t}, {\n\t\tkey: 'remove',\n\n\n\t\t/**\r\n   * Remove this particle element from the DOM\r\n   */\n\t\tvalue: function remove() {\n\t\t\tif (this.$element) {\n\t\t\t\tthis.$element.remove();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_render',\n\n\n\t\t/**\r\n   * Render the particle in the dom\r\n   */\n\t\tvalue: function _render() {\n\t\t\tif (this.ctx) {\n\t\t\t\tthis.ctx.fillStyle = this._settings.append_to.css('color');\n\t\t\t\tthis.ctx.beginPath();\n\t\t\t\tthis.ctx.arc(this.coordinates.x, this.coordinates.y, this.size, 0, 2 * Math.PI);\n\t\t\t\tthis.ctx.closePath();\n\t\t\t\tthis.ctx.fill();\n\t\t\t} else if (this.$element) {\n\t\t\t\t// TODO:  look into rendering to a canvas\n\t\t\t\tthis.$element.css({\n\t\t\t\t\t'top': 0,\n\t\t\t\t\t'left': 0,\n\t\t\t\t\t'transform': 'translate(' + (this.coordinates.x - this.height / 2) + 'px, ' + (this.coordinates.y - this.width / 2) + 'px)',\n\t\t\t\t\t'width': this.width + 'px',\n\t\t\t\t\t'height': this.height + 'px'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'TTL',\n\n\n\t\t/**\r\n   * Get this particles remaining Time To Live\r\n   * @returns {Number}\r\n   */\n\t\tget: function get() {\n\t\t\treturn this._ttl;\n\t\t}\n\t}]);\n\n\treturn Particle;\n}();\n\n;\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*****************************************************************************************************/\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Description:  Particle Emitters which creates & updates Particles \t\t\t\t\t\t\t\t**/\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/*****************************************************************************************************/\n\n/**\r\n * ParticleEmitter class, controls Particles\r\n */\nvar ParticleEmitter = function () {\n\n\t/**\r\n  * Creates a ParticleEmitter object with the given configuration.  Note that the settings should not be changed dynamically,\r\n  *  \tas there are some optimization that causes some of the initial configuration settings to become stale.  Changing these\r\n  *  \tsettings after the emitter is initialized, would have unintended results.\r\n  * @param {Object} cfg - default settings for emitter\r\n  * @property {jQuery} cfg.element - jquery element to calculate spawn location\r\n \t * @property {Boolean} cfg.active - status of emitter when intiailized (on/off)\r\n \t * @property {Number} cfg.max_particles - max number of particle the emitter can hold\r\n \t * @property {Object|Number} cfg.emit_delay - random time between particle emissions or a single constant value\r\n \t * @property {Number} cfg.emit_delay.min\r\n \t * @property {Number} cfg.emit_delay.max\r\n \t * @property {Object|String} cfg.direction - random direction range to move particles, or special string 'in' to aim randomly inwards if spawn_point is 'outside'\r\n \t * @property {Number} cfg.direction.min - min range in degrees (0 moves up, 90 right, 180 down, 270 left)\r\n \t * @property {Number} cfg.direction.max - max range in degrees (360 moves up)\r\n  * @property {String} cfg.spawn_point - particle spawn location within emitter element ('center', 'random', null for top-left corner of element)\r\n \t * @property {Object} cfg.particle - default particle settings\r\n \t * @property {Class} cfg.particle.constructor - reference to class (Ex: Particle)\r\n \t * @property {jQuery} cfg.particle.append_to - element to append particles to\r\n \t * @property {String} cfg.particle.template - an html string template to create particles with\r\n \t * @property {Number} cfg.particle.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.particle.speed_amt - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.particle.size_amt - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.particle.size - size of particle in canvas\r\n  * @constructor\r\n  */\n\tfunction ParticleEmitter() {\n\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\tvar debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t_classCallCheck(this, ParticleEmitter);\n\n\t\t// OPTIMIZATION: 1 time calculation\n\t\tvar radians = -Math.PI / 180;\n\n\t\t// setup default settings, given configuration\n\t\tthis._settings = $.extend(true, {\n\t\t\tactive: false,\n\t\t\telement: $('body'),\n\t\t\tmax_particles: 100,\n\t\t\temit_delay: { min: 100, max: 100 },\n\t\t\tdirection: { min: 0, max: 360 },\n\t\t\tspawn_point: 'center',\n\n\t\t\tparticle: {\n\t\t\t\tconstructor: Particle,\n\t\t\t\tappend_to: $('body'),\n\t\t\t\ttemplate: '<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>',\n\t\t\t\ttime_to_live: 2000,\n\t\t\t\tspeed_amt: 70,\n\t\t\t\tsize_amt: 0,\n\t\t\t\tsize: 10\n\t\t\t}\n\t\t}, cfg);\n\n\t\t// array of particles\n\t\tthis.particles = [];\n\n\t\t// dom jquery reference to emitter element\n\t\tthis.$element = this._settings.element;\n\n\t\t// width & height for calculating spawn location within dom $element\n\t\tthis.width = this.$element.outerWidth();\n\t\tthis.height = this.$element.outerHeight();\n\n\t\t// check if element is a canvas object\n\t\tthis.ctx = null;\n\t\tif (this.$element.is('canvas')) {\n\t\t\tthis.ctx = this.$element[0].getContext('2d');\n\t\t\tthis._settings.particle.append_to = this.$element;\n\t\t}\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// for debugging purposes (used for console logging)\n\t\tthis._debug = debug;\n\n\t\t// whether or not this emitter is actively emitting particles\n\t\tthis._active = this._settings.active;\n\n\t\t// whether or not this emitter has been destroyed/removed\n\t\tthis._destroyed = false;\n\n\t\t// remember timeout for trigger callback (to clear when toggling)\n\t\tthis._triggerCallback = null;\n\n\t\t// initial spawn point offset and position of emitter\n\t\tthis._spawn_position = {};\n\n\t\t// total delay amount\n\t\tthis._delay = 0;\n\n\t\t// elapsed time\n\t\tthis._time = new Date();\n\t\tthis._elapsed_time = this._time.getTime();\n\n\t\t// OPTIMIZATION: convert direction in degrees to radians (in degree's initially b/c those are easier for people to understand, but radians are required)\n\t\t//\t\t\t\t\talso subtract 90 degree's so that 0 is aimed upwards, b/c that too makes more sense\n\t\tif (_typeof(this._settings.direction) == 'object') {\n\t\t\tthis._settings.direction.min = (this._settings.direction.min - 90) * radians;\n\t\t\tthis._settings.direction.max = (this._settings.direction.max - 90) * radians;\n\t\t} else if (this._settings.direction == 'in' && this._settings.spawn_point == 'outside') {\n\t\t\t// special case when spawning \"outside\" to point inwards\n\t\t\tthis.left = { min: (180 - 90) * radians, max: (360 - 90) * radians };\n\t\t\tthis.right = { min: (0 - 90) * radians, max: (360 - 90) * radians };\n\t\t\tthis.up = { min: (-90 - 90) * radians, max: (90 - 90) * radians };\n\t\t\tthis.down = { min: (90 - 90) * radians, max: (270 - 90) * radians };\n\t\t} else {\n\t\t\tthis._settings.direction.min = (0 - 90) * radians;\n\t\t\tthis._settings.direction.max = (360 - 90) * radians;\n\t\t}\n\n\t\t// OPTIMIZATION: adjust speed & size from seconds to milliseconds (again, seconds are easier to understand than milliseconds, but milliseconds are required)\n\t\tif (this._settings.particle.speed_amt > 0) {\n\t\t\tthis._settings.particle.speed_amt /= 1000;\n\t\t}\n\t\tif (this._settings.particle.size_amt > 0) {\n\t\t\tthis._settings.particle.size_amt /= 1000;\n\t\t}\n\n\t\t// OPTIMIZATION: create a spawn point relative to the $element (\"center\" and default \"null\" here as an optimization, \"random\" is handled below inside particleSpawnPosition)\n\t\tthis._spawn_position = {\n\t\t\tx: this._settings.spawn_point == 'center' ? this.width / 2 : 0,\n\t\t\ty: this._settings.spawn_point == 'center' ? this.height / 2 : 0\n\t\t};\n\t}\n\n\t/**\r\n  * update emitter by updating, adding, and removing particles\r\n  */\n\n\n\t_createClass(ParticleEmitter, [{\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\t\t\t// calculate time since last update\n\t\t\tvar now = new Date();\n\t\t\tthis._elapsed_time = now - this._time;\n\n\t\t\t// a cap for elapsed time for slower computers, b/c if you don't, you end up not even seeing any particles as the screen updates too slowly\n\t\t\t// the idea is that I'd rather see slow moving particles, than none at all\n\t\t\tif (this._elapsed_time > 500) {\n\t\t\t\t// TODO: instead of capping elapsed time, find a way to pre-calculate/optimize for the computer in question (by removing particles, capping max particle count, and/or increasing time between emissions)\n\t\t\t\tif (this._debug) {\n\t\t\t\t\tconsole.log('Particle System: Capping elapsed time at 500 (was ' + this._elapsed_time + ')');\n\t\t\t\t}\n\t\t\t\tthis._elapsed_time = 500;\n\t\t\t}\n\n\t\t\t// only create particles if emitter is set to active\n\t\t\tif (this._active) {\n\t\t\t\tthis._createParticles(this._elapsed_time);\n\t\t\t}\n\n\t\t\t// update & remove particles by telling them how much time as passed since the last update\n\t\t\tthis._updateParticles(this._elapsed_time);\n\n\t\t\t// reset elapsed time to the current time after all updates have occured\n\t\t\tthis._time = new Date().getTime();\n\t\t}\n\n\t\t/**\r\n   * Create & append a particle given spawn_point and direction\r\n   * @param {Object} spawn_point - global coordinates to create particle at\r\n   * @param {Number} spawn_point.x\r\n   * @param {Number} spawn_point.y\r\n   * @param {Number} [direction] - direction in degrees, for particle to move\r\n   */\n\n\t}, {\n\t\tkey: 'addParticle',\n\t\tvalue: function addParticle(spawn_point) {\n\t\t\tvar direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\tvar min = 0,\n\t\t\t    max = 360;\n\n\t\t\t// if no direction was given, create a random direction based on settings\n\t\t\tif (!direction && _typeof(this._settings.direction) == 'object') {\n\t\t\t\tmax = this._settings.direction.max;\n\t\t\t\tmin = this._settings.direction.min;\n\t\t\t} else {\n\t\t\t\t// direction should point inwards if special string 'in' case\n\n\t\t\t\t// no direction & spawned top\n\t\t\t\tif (!direction && spawn_point.location === 'top') {\n\t\t\t\t\tmax = this.down.max;\n\t\t\t\t\tmin = this.down.min;\n\t\t\t\t}\n\n\t\t\t\t// no direction & spawned bottom\n\t\t\t\tif (!direction && spawn_point.location === 'bottom') {\n\t\t\t\t\tmax = this.up.max;\n\t\t\t\t\tmin = this.up.min;\n\t\t\t\t}\n\n\t\t\t\t// no direction & spawned left\n\t\t\t\tif (!direction && spawn_point.location === 'left') {\n\t\t\t\t\tmax = this.right.max;\n\t\t\t\t\tmin = this.right.min;\n\t\t\t\t}\n\n\t\t\t\t// no direction & spawned right\n\t\t\t\tif (!direction && spawn_point.location === 'right') {\n\t\t\t\t\tmax = this.left.max;\n\t\t\t\t\tmin = this.left.min;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!direction) {\n\t\t\t\tdirection = Math.random() * (max - min) + min;\n\t\t\t}\n\n\t\t\t// create a particle and append it to list\n\t\t\tthis.particles.push(new this._settings.particle.constructor(spawn_point, direction, this._settings.particle, this._debug, this.ctx));\n\t\t}\n\n\t\t/**\r\n   * Trigger this emitter for x amount of time\r\n   * @param {Number} amount - how long to emit particles for\r\n   * @param {Function|Callback} [callback] - optional function to call when completed\r\n   */\n\n\t}, {\n\t\tkey: 'trigger',\n\t\tvalue: function trigger(amount, callback) {\n\t\t\tvar _this = this;\n\n\t\t\t// set this emitter to active state\n\t\t\tthis._active = true;\n\n\t\t\t// setup a delay callback to disable the emitter\n\t\t\tthis._triggerCallback = window.setTimeout(function () {\n\t\t\t\t_this._active = false;\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call();\n\t\t\t\t}\n\t\t\t}, amount);\n\t\t}\n\n\t\t/**\r\n   * Toggle emitter on/off\r\n   */\n\n\t}, {\n\t\tkey: 'toggle',\n\t\tvalue: function toggle() {\n\t\t\t// toggle boolean activate status\n\t\t\tthis._active = !this._active;\n\n\t\t\t// clear trigger function's callback, so that toggle and trigger don't conflict as much\n\t\t\tif (this._triggerCallback) {\n\t\t\t\twindow.clearTimeout(this._triggerCallback);\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Turn emitter on\r\n   */\n\n\t}, {\n\t\tkey: 'activate',\n\t\tvalue: function activate() {\n\t\t\tthis._active = true;\n\t\t}\n\n\t\t/**\r\n   * Turn emitter off\r\n   */\n\n\t}, {\n\t\tkey: 'deactivate',\n\t\tvalue: function deactivate() {\n\t\t\tthis._active = false;\n\t\t}\n\n\t\t/**\r\n   * Call particles remove function and then remove particle from array\r\n   */\n\n\t}, {\n\t\tkey: 'remove',\n\t\tvalue: function remove() {\n\t\t\tthis._destroyed = true;\n\t\t\tfor (var i = 0; i < this.particles.length; i++) {\n\t\t\t\tthis.particles[i].remove();\n\t\t\t\tthis.particles.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Calculate & Return the global spawn position of particle\r\n   * @returns {x: number, y: number}\r\n   */\n\n\t}, {\n\t\tkey: '_updateParticles',\n\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t/**\r\n   * Update and remove particles based on the particles Time To Live (TTL)\r\n   * @param {Number} elapsed_time\r\n   */\n\t\tvalue: function _updateParticles(elapsed_time) {\n\t\t\t// clear canvas if emitter is attached to a canvas element\n\t\t\tif (this.ctx) {\n\t\t\t\tthis.ctx.clearRect(0, 0, this.width, this.height);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < this.particles.length; i++) {\n\t\t\t\tvar p = this.particles[i];\n\t\t\t\tp.update(elapsed_time);\n\n\t\t\t\t// call particles remove function to remove element from DOM then remove particle class from particle array\n\t\t\t\tif (p.TTL <= 0) {\n\t\t\t\t\tp.remove();\n\t\t\t\t\tthis.particles.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Create as many particles as the emit_delay & max_particles settings will allow\r\n   * @param {Number} elapsed_time\r\n   */\n\n\t}, {\n\t\tkey: '_createParticles',\n\t\tvalue: function _createParticles(elapsed_time) {\n\t\t\t// find the emitters exact position to spawn particles at for this update call (changes per update if random)\n\t\t\tvar spawn_point = this.particleSpawnPosition;\n\n\t\t\t// calculate the emit_delay amount for this update call (either a random amount between min/max or a standard number)\n\t\t\tvar delay_settings = this._settings.emit_delay;\n\t\t\tvar emit_delay = delay_settings.min || delay_settings.max ? Math.random() * (delay_settings.max - delay_settings.min) + delay_settings.min : delay_settings;\n\n\t\t\t// create as many particles as the delay & max particle count will allow based on time since last update\n\t\t\tif (this.particles.length < this._settings.max_particles) {\n\t\t\t\tthis._delay -= this._elapsed_time;\n\t\t\t\t// if emit_delay is 0, loop until all possible particles have been created\n\t\t\t\twhile (this._delay <= 0 && this.particles.length < this._settings.max_particles) {\n\t\t\t\t\tthis._delay += emit_delay;\n\n\t\t\t\t\t// create & append a particle at the given global spawn coordinates\n\t\t\t\t\tthis.addParticle(spawn_point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'particleSpawnPosition',\n\t\tget: function get() {\n\t\t\tvar offset = this.$element.offset();\n\t\t\tvar spawn_point = { x: offset.left + this._spawn_position.x, y: offset.top + this._spawn_position.y };\n\n\t\t\tif (this._settings.spawn_point == 'random') {\n\t\t\t\tspawn_point.x += Math.random() * this.width;\n\t\t\t\tspawn_point.y += Math.random() * this.height;\n\t\t\t} else if (this._settings.spawn_point == 'outside') {\n\t\t\t\tif (Math.round(Math.random())) {\n\t\t\t\t\t// spawn top or bottom\n\t\t\t\t\tspawn_point.x += Math.random() * this.width;\n\n\t\t\t\t\tif (Math.round(Math.random())) {\n\t\t\t\t\t\tspawn_point.y += this.height;\n\t\t\t\t\t\tspawn_point.location = 'bottom';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspawn_point.location = 'top';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// spawn left or right\n\t\t\t\t\tspawn_point.y += Math.random() * this.height;\n\n\t\t\t\t\tif (Math.round(Math.random())) {\n\t\t\t\t\t\tspawn_point.x += this.width;\n\t\t\t\t\t\tspawn_point.location = 'right';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspawn_point.location = 'left';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn spawn_point;\n\t\t}\n\n\t\t/**\r\n   * Check to see if this Emitter is destroyed\r\n   */\n\n\t}, {\n\t\tkey: 'isDestroyed',\n\t\tget: function get() {\n\t\t\treturn this._destroyed;\n\t\t}\n\t}]);\n\n\treturn ParticleEmitter;\n}();\n\n;\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*****************************************************************************************************/\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Description:  Particle System that controls Particle Emitters which in turn control Particles \t**/\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/*****************************************************************************************************/\n\n/**\r\n * ParticleSystem class, controls Emitters which in turn control Particles\r\n */\nvar ParticleSystem = function () {\n\n\t/**\r\n  * Creates a ParticleSystem object\r\n  * @param {Object} cfg - default particle system settings\r\n \t * @deprecated {Number} cfg.timeout - time between update intervals for the particle system\r\n  * @constructor\r\n \t */\n\tfunction ParticleSystem() {\n\t\tvar _this = this;\n\n\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\tvar debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t_classCallCheck(this, ParticleSystem);\n\n\t\t// setup default settings, given configuration\n\t\tthis._settings = $.extend(true, {\n\t\t\ttimeout: 30\n\t\t}, cfg);\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// for debugging purposes (used for console logging)\n\t\tthis._debug = debug;\n\n\t\t// particle system emitters\n\t\tthis._particle_emitters = [];\n\n\t\t/*********************************************************************************\r\n  **  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// start a loop for the updating and rendering of emitters and particles\n\t\tif (window.requestAnimationFrame) {\n\t\t\tvar update = function update() {\n\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\t_this._update();window.requestAnimationFrame(update);\n\t\t\t\t}, _this._settings.timeout);\n\t\t\t};\n\t\t\tupdate();\n\t\t} else {\n\t\t\twindow.setInterval(function () {\n\t\t\t\t_this._update();\n\t\t\t}, this._settings.timeout);\n\t\t}\n\t}\n\n\t/**\r\n  * Add a particle emitter to the emitter list for updating/rendering purposes\r\n  * @returns {class} Emitter - return a reference to emitter in case someone wants to chain function calls together\r\n  */\n\n\n\t_createClass(ParticleSystem, [{\n\t\tkey: \"addEmitter\",\n\t\tvalue: function addEmitter(Emitter) {\n\t\t\tthis._particle_emitters.push(Emitter);\n\t\t\treturn Emitter;\n\t\t}\n\n\t\t/**\r\n   * Remove emitter from the particle system\r\n   * @param {class} Emitter\r\n   */\n\n\t}, {\n\t\tkey: \"removeEmitter\",\n\t\tvalue: function removeEmitter(Emitter) {\n\t\t\tfor (var i = 0; i < this._particle_emitters.length; i++) {\n\t\t\t\tif (Emitter == this._particle_emitters[i]) {\n\t\t\t\t\tthis._particle_emitters[i].remove(); // call the emitters remove function (which will call each particles remote function, among other things)\n\t\t\t\t\tthis._particle_emitters.splice(i, 1); // remove this emitter from the particle system\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t/**\r\n   * update each Particle Emitter contained within this Particle System\r\n   */\n\n\t}, {\n\t\tkey: \"_update\",\n\t\tvalue: function _update() {\n\t\t\tfor (var i = 0; i < this._particle_emitters.length; i++) {\n\t\t\t\tvar Emitter = this._particle_emitters[i];\n\n\t\t\t\t// check if emitter is destroyed/removed, if so remove it from particle system (mostly just cleanup)\n\t\t\t\t// TODO:  Some day this \"destroy\" check would be better accomplished with an event listener\n\t\t\t\tif (Emitter.isDestroyed) {\n\t\t\t\t\tthis._particle_emitters.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t} else {\n\t\t\t\t\tEmitter.update();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn ParticleSystem;\n}();\n\n;","/*****************************************************************************************************/\r\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Description:  A Particle class for controlling how a single particle behaves\t\t\t\t\t**/\r\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/*****************************************************************************************************/\r\n\r\n\r\n/**\r\n * Particle class\r\n */\r\nclass Particle {\r\n\r\n\t/**\r\n\t * Create a Particle object\r\n\t * @param {Object} spawn_point - x, y spawn point of particle\r\n\t * @param {Number} spawn_point.x\r\n\t * @param {Number} spawn_point.y\r\n\t * @param {Number} direction - direction to move particle in radians\r\n\t * @param {Object} cfg - default particle settings\r\n \t * @property {jQuery} cfg.append_to - element to append particles to\r\n \t * @property {String} cfg.template - an html string template to create particles with\r\n \t * @property {Number} cfg.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.speed - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.size - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n\t * @param {Boolean} [debug]\r\n\t * @param {DOM} [ctx] - context of canvas element\r\n\t * @constructor\r\n\t */\r\n\tconstructor(spawn_point, direction, cfg = {}, debug = false, ctx = null) {\r\n\t\t// setup default settings, given configuration\r\n\t\tthis._settings = $.extend(true, {\r\n\t\t\tappend_to: $('body'),\r\n\t\t\ttemplate: `<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>`,\r\n\t\t\ttime_to_live: 2000,\r\n\t\t\tspeed_amt: 10,\r\n\t\t\tsize_amt: 0,\r\n\t\t\tsize: 10\r\n\t\t}, cfg);\r\n\r\n\t\tif (!ctx) {\r\n\t\t\t// create a DOM object given a template, and hide so that it has dimension, but can't be seen until positioned\r\n\t\t\tthis.$element = $(this._settings.template).css('visibility', 'hidden');\r\n\t\t\t\r\n\t\t\t// append particle element to an element on the page\r\n\t\t\tthis.$element.appendTo(this._settings.append_to);\r\n\r\n\t\t\t// get width and height of element for positioning purposes\r\n\t\t\tthis.width = this.$element.width();\r\n\t\t\tthis.height = this.$element.height();\r\n\t\t}\r\n\r\n\t\t// convert the global spawn_point coordinates into their appropriate local coordinates (based off the closest positioned parent)\r\n\t\tvar local_coords = (this.$element)? this.$element.offsetParent().offset(): this._settings.append_to.offset();\r\n\r\n\t\tthis.coordinates = {x: spawn_point.x - local_coords.left, y: spawn_point.y - local_coords.top};\r\n\r\n\t\tthis.size_amt = this._settings.size_amt;\r\n\t\tthis.speed_amt = this._settings.speed_amt;\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// for debugging purposes (used for console logging)\r\n\t\tthis._debug = debug;\r\n\r\n\t\t// OPTIMIZATION: velocity/movement amount based on speed and direction\r\n\t\tthis._vx = this.speed_amt * (Math.cos(direction));\r\n\t\tthis._vy = this.speed_amt * (-Math.sin(direction));\r\n\r\n\t\t// how long the particle will exist before it's removal\r\n\t\tthis._ttl = this._settings.time_to_live;\r\n\r\n\t\t// store reference to context of canvas elements\r\n\t\tthis.ctx = ctx;\r\n\r\n\t\t// default size of canvas particles\r\n\t\tthis.size = this._settings.size;\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\tif (!ctx) {\r\n\t\t\t// set visibility so that the particle can now be seen (it was hidden until position calculations were complete)\r\n\t\t\tthis.$element.css({\r\n\t\t\t\t'position': 'absolute',\r\n\t\t\t\t'visibility': 'visible'\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// render the particle\r\n\t\tthis._render();\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @param {Number} elapsed_time - how long since the emitter/particle was last updated\r\n\t */\r\n\tupdate(elapsed_time) {\r\n\t\t// adjust particles time to live value (life time)\r\n\t\tthis.reduceTTL(elapsed_time);\r\n\r\n\t\t// adjust particles coordinates\r\n\t\tthis.move(elapsed_time);\r\n\r\n\t\t// adjust width & height based on size increase/decrease setting\r\n\t\tthis.width += this.size_amt * elapsed_time;\r\n\t\tthis.height += this.size_amt * elapsed_time;\r\n\r\n\t\t// render element (update in dom)\r\n\t\tthis._render();\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Reduce the particles life based on elapsed time\r\n\t * @param elapsed_time\r\n\t */\r\n\treduceTTL(elapsed_time) {\r\n\t\tthis._ttl -= elapsed_time;\r\n\t};\r\n\r\n\t/**\r\n\t * Move particle based on speed, direction, and time since last update\r\n\t * @param elapsed_time\r\n\t */\r\n\tmove(elapsed_time) {\r\n\t\tthis.coordinates.x += this._vx * elapsed_time;\r\n\t\tthis.coordinates.y += this._vy * elapsed_time;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove this particle element from the DOM\r\n\t */\r\n\tremove() {\r\n\t\tif (this.$element) {\r\n\t\t\tthis.$element.remove();\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Get this particles remaining Time To Live\r\n\t * @returns {Number}\r\n\t */\r\n\tget TTL() {\r\n\t\treturn this._ttl;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Render the particle in the dom\r\n\t */\r\n\t_render() {\r\n\t\tif (this.ctx) {\r\n\t\t\tthis.ctx.fillStyle = this._settings.append_to.css('color');\r\n\t\t\tthis.ctx.beginPath();\r\n\t\t\tthis.ctx.arc(this.coordinates.x, this.coordinates.y, this.size, 0, 2 * Math.PI);\r\n\t\t\tthis.ctx.closePath();\r\n\t\t\tthis.ctx.fill()\r\n\t\t} else if (this.$element) {\r\n\t\t\t// TODO:  look into rendering to a canvas\r\n\t\t\tthis.$element.css({\r\n\t\t\t\t'top': 0,\r\n\t\t\t\t'left': 0,\r\n\t\t\t\t'transform': 'translate(' + (this.coordinates.x - (this.height / 2)) + 'px, ' + (this.coordinates.y - (this.width / 2)) + 'px)',\r\n\t\t\t\t'width': this.width + 'px',\r\n\t\t\t\t'height': this.height + 'px'\r\n\t\t\t});\r\n\t\t\t\r\n\t\t}\r\n\t};\r\n};\r\n","/*****************************************************************************************************/\r\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Description:  Particle Emitters which creates & updates Particles \t\t\t\t\t\t\t\t**/\r\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/*****************************************************************************************************/\r\n\r\n\r\n/**\r\n * ParticleEmitter class, controls Particles\r\n */\r\nclass ParticleEmitter {\r\n\r\n\t/**\r\n\t * Creates a ParticleEmitter object with the given configuration.  Note that the settings should not be changed dynamically,\r\n\t *  \tas there are some optimization that causes some of the initial configuration settings to become stale.  Changing these\r\n\t *  \tsettings after the emitter is initialized, would have unintended results.\r\n\t * @param {Object} cfg - default settings for emitter\r\n\t * @property {jQuery} cfg.element - jquery element to calculate spawn location\r\n \t * @property {Boolean} cfg.active - status of emitter when intiailized (on/off)\r\n \t * @property {Number} cfg.max_particles - max number of particle the emitter can hold\r\n \t * @property {Object|Number} cfg.emit_delay - random time between particle emissions or a single constant value\r\n \t * @property {Number} cfg.emit_delay.min\r\n \t * @property {Number} cfg.emit_delay.max\r\n \t * @property {Object|String} cfg.direction - random direction range to move particles, or special string 'in' to aim randomly inwards if spawn_point is 'outside'\r\n \t * @property {Number} cfg.direction.min - min range in degrees (0 moves up, 90 right, 180 down, 270 left)\r\n \t * @property {Number} cfg.direction.max - max range in degrees (360 moves up)\r\n\t * @property {String} cfg.spawn_point - particle spawn location within emitter element ('center', 'random', null for top-left corner of element)\r\n \t * @property {Object} cfg.particle - default particle settings\r\n \t * @property {Class} cfg.particle.constructor - reference to class (Ex: Particle)\r\n \t * @property {jQuery} cfg.particle.append_to - element to append particles to\r\n \t * @property {String} cfg.particle.template - an html string template to create particles with\r\n \t * @property {Number} cfg.particle.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.particle.speed_amt - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.particle.size_amt - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.particle.size - size of particle in canvas\r\n\t * @constructor\r\n\t */\r\n\tconstructor(cfg = {}, debug = false) {\r\n\t\t// OPTIMIZATION: 1 time calculation\r\n\t\tvar radians = -Math.PI / 180;\r\n\r\n\t\t// setup default settings, given configuration\r\n\t\tthis._settings = $.extend(true, {\r\n\t\t\tactive: false,\r\n\t\t\telement: $('body'),\r\n\t\t\tmax_particles: 100,\r\n\t\t\temit_delay: { min: 100, max: 100 },\r\n\t\t\tdirection: { min: 0, max: 360 },\r\n\t\t\tspawn_point: 'center',\r\n\r\n\t\t\tparticle: {\r\n\t\t\t\tconstructor: Particle,\r\n\t\t\t\tappend_to: $('body'),\r\n\t\t\t\ttemplate: `<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>`,\r\n\t\t\t\ttime_to_live: 2000,\r\n\t\t\t\tspeed_amt: 70,\r\n\t\t\t\tsize_amt: 0,\r\n\t\t\t\tsize: 10\r\n\t\t\t}\r\n\t\t}, cfg);\r\n\r\n\t\t// array of particles\r\n\t\tthis.particles = [];\r\n\r\n\t\t// dom jquery reference to emitter element\r\n\t\tthis.$element = this._settings.element;\r\n\r\n\t\t// width & height for calculating spawn location within dom $element\r\n\t\tthis.width = this.$element.outerWidth();\r\n\t\tthis.height = this.$element.outerHeight();\r\n\r\n\t\t// check if element is a canvas object\r\n\t\tthis.ctx = null;\r\n\t\tif (this.$element.is('canvas')) {\r\n\t\t\tthis.ctx = this.$element[0].getContext('2d');\r\n\t\t\tthis._settings.particle.append_to = this.$element;\r\n\t\t}\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// for debugging purposes (used for console logging)\r\n\t\tthis._debug = debug;\r\n\r\n \t\t// whether or not this emitter is actively emitting particles\r\n \t\tthis._active = this._settings.active;\r\n\r\n\t\t// whether or not this emitter has been destroyed/removed\r\n\t\tthis._destroyed = false;\r\n\r\n\t\t // remember timeout for trigger callback (to clear when toggling)\r\n\t\tthis._triggerCallback = null;\r\n\r\n\t\t// initial spawn point offset and position of emitter\r\n\t\tthis._spawn_position = {};\r\n\r\n\t\t// total delay amount\r\n\t\tthis._delay = 0;\r\n\r\n\t\t// elapsed time\r\n\t\tthis._time = new Date();\r\n\t\tthis._elapsed_time = this._time.getTime();\r\n\r\n\t\t// OPTIMIZATION: convert direction in degrees to radians (in degree's initially b/c those are easier for people to understand, but radians are required)\r\n\t\t//\t\t\t\t\talso subtract 90 degree's so that 0 is aimed upwards, b/c that too makes more sense\r\n\t\tif (typeof this._settings.direction == 'object') {\r\n\t\t\tthis._settings.direction.min = (this._settings.direction.min - 90) * radians;\r\n\t\t\tthis._settings.direction.max = (this._settings.direction.max - 90) * radians;\r\n\t\t} else if (this._settings.direction == 'in' && this._settings.spawn_point == 'outside') {\r\n\t\t\t// special case when spawning \"outside\" to point inwards\r\n\t\t\tthis.left = { min: (180 - 90) * radians, max: (360 - 90) * radians };\r\n\t\t\tthis.right = { min: (0 - 90) * radians, max: (360 - 90) * radians };\r\n\t\t\tthis.up = { min: (-90 - 90) * radians, max: (90 - 90) * radians };\r\n\t\t\tthis.down = { min: (90 - 90) * radians, max: (270 - 90) * radians };\r\n\t\t} else {\r\n\t\t\tthis._settings.direction.min = (0 - 90) * radians;\r\n\t\t\tthis._settings.direction.max = (360 - 90) * radians;\r\n\t\t}\r\n\r\n\r\n\t\t// OPTIMIZATION: adjust speed & size from seconds to milliseconds (again, seconds are easier to understand than milliseconds, but milliseconds are required)\r\n\t\tif (this._settings.particle.speed_amt > 0) { this._settings.particle.speed_amt /= 1000; }\r\n\t\tif (this._settings.particle.size_amt > 0) { this._settings.particle.size_amt /= 1000; }\r\n\r\n\t\t// OPTIMIZATION: create a spawn point relative to the $element (\"center\" and default \"null\" here as an optimization, \"random\" is handled below inside particleSpawnPosition)\r\n\t\tthis._spawn_position = {\r\n\t\t\tx: (this._settings.spawn_point == 'center')? (this.width / 2): 0,\r\n\t\t\ty: (this._settings.spawn_point == 'center')? (this.height / 2): 0\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * update emitter by updating, adding, and removing particles\r\n\t */\r\n\tupdate() {\r\n\t\t// calculate time since last update\r\n\t\tvar now = new Date();\r\n\t\tthis._elapsed_time = now - this._time;\r\n\r\n\t\t// a cap for elapsed time for slower computers, b/c if you don't, you end up not even seeing any particles as the screen updates too slowly\r\n\t\t// the idea is that I'd rather see slow moving particles, than none at all\r\n\t\tif (this._elapsed_time > 500) {\r\n\t\t\t// TODO: instead of capping elapsed time, find a way to pre-calculate/optimize for the computer in question (by removing particles, capping max particle count, and/or increasing time between emissions)\r\n\t\t\tif (this._debug) { console.log('Particle System: Capping elapsed time at 500 (was '+this._elapsed_time+')'); }\r\n\t\t\tthis._elapsed_time = 500;\r\n\t\t}\r\n\r\n\t\t// only create particles if emitter is set to active\r\n\t\tif (this._active) {\r\n\t\t\tthis._createParticles(this._elapsed_time);\r\n\t\t}\r\n\r\n\t\t// update & remove particles by telling them how much time as passed since the last update\r\n\t\tthis._updateParticles(this._elapsed_time);\r\n\r\n\t\t// reset elapsed time to the current time after all updates have occured\r\n\t\tthis._time = (new Date()).getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * Create & append a particle given spawn_point and direction\r\n\t * @param {Object} spawn_point - global coordinates to create particle at\r\n\t * @param {Number} spawn_point.x\r\n\t * @param {Number} spawn_point.y\r\n\t * @param {Number} [direction] - direction in degrees, for particle to move\r\n\t */\r\n\taddParticle(spawn_point, direction = null) {\r\n\t\tlet min = 0, max = 360;\r\n\r\n\t\t// if no direction was given, create a random direction based on settings\r\n\t\tif (!direction && typeof this._settings.direction == 'object') {\r\n\t\t\tmax = this._settings.direction.max;\r\n\t\t\tmin = this._settings.direction.min;\r\n\t\t} else {\r\n\t\t\t// direction should point inwards if special string 'in' case\r\n\r\n\t\t\t// no direction & spawned top\r\n\t\t\tif (!direction && spawn_point.location === 'top') {\r\n\t\t\t\tmax = this.down.max;\r\n\t\t\t\tmin = this.down.min;\r\n\t\t\t}\r\n\r\n\t\t\t// no direction & spawned bottom\r\n\t\t\tif (!direction && spawn_point.location === 'bottom') {\r\n\t\t\t\tmax = this.up.max;\r\n\t\t\t\tmin = this.up.min;\r\n\t\t\t}\r\n\r\n\t\t\t// no direction & spawned left\r\n\t\t\tif (!direction && spawn_point.location === 'left') {\r\n\t\t\t\tmax = this.right.max;\r\n\t\t\t\tmin = this.right.min;\r\n\t\t\t}\r\n\r\n\t\t\t// no direction & spawned right\r\n\t\t\tif (!direction && spawn_point.location === 'right') {\r\n\t\t\t\tmax = this.left.max;\r\n\t\t\t\tmin = this.left.min;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!direction) {\r\n\t\t\tdirection = (Math.random() * (max - min)) + min;\r\n\t\t}\r\n\r\n\t\t// create a particle and append it to list\r\n\t\tthis.particles.push(new this._settings.particle.constructor(spawn_point, direction, this._settings.particle, this._debug, this.ctx));\r\n\t}\r\n\r\n\t/**\r\n\t * Trigger this emitter for x amount of time\r\n\t * @param {Number} amount - how long to emit particles for\r\n\t * @param {Function|Callback} [callback] - optional function to call when completed\r\n\t */\r\n\ttrigger(amount, callback) {\r\n\t\t// set this emitter to active state\r\n\t\tthis._active = true;\r\n\r\n\t\t// setup a delay callback to disable the emitter\r\n\t\tthis._triggerCallback = window.setTimeout(() => {\r\n\t\t\tthis._active = false;\r\n\t\t\tif (callback) { callback.call(); }\r\n\t\t}, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * Toggle emitter on/off\r\n\t */\r\n\ttoggle() {\r\n\t\t// toggle boolean activate status\r\n\t\tthis._active = !this._active;\r\n\r\n\t\t// clear trigger function's callback, so that toggle and trigger don't conflict as much\r\n\t\tif (this._triggerCallback) { window.clearTimeout(this._triggerCallback); }\r\n\t}\r\n\r\n\t/**\r\n\t * Turn emitter on\r\n\t */\r\n\tactivate() {\r\n\t\tthis._active = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Turn emitter off\r\n\t */\r\n\tdeactivate() {\r\n\t\tthis._active = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Call particles remove function and then remove particle from array\r\n\t */\r\n\tremove() {\r\n\t\tthis._destroyed = true;\r\n\t\tfor (let i=0; i<this.particles.length; i++) {\r\n\t\t\tthis.particles[i].remove();\r\n\t\t\tthis.particles.splice(i, 1);\r\n\t\t\ti--;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate & Return the global spawn position of particle\r\n\t * @returns {x: number, y: number}\r\n\t */\r\n\tget particleSpawnPosition() {\r\n\t\tvar offset = this.$element.offset();\r\n\t\tvar spawn_point = {x: offset.left + this._spawn_position.x, y: offset.top + this._spawn_position.y};\r\n\r\n\t\tif (this._settings.spawn_point == 'random') {\r\n\t\t\tspawn_point.x += Math.random() * this.width;\r\n\t\t\tspawn_point.y += Math.random() * this.height;\r\n\t\t} else if (this._settings.spawn_point == 'outside') {\r\n\t\t\tif (Math.round(Math.random())) {\r\n\t\t\t\t// spawn top or bottom\r\n\t\t\t\tspawn_point.x += Math.random() * this.width;\r\n\r\n\t\t\t\tif (Math.round(Math.random())) {\r\n\t\t\t\t\tspawn_point.y += this.height;\r\n\t\t\t\t\tspawn_point.location = 'bottom';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tspawn_point.location = 'top';\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// spawn left or right\r\n\t\t\t\tspawn_point.y += Math.random() * this.height;\r\n\r\n\t\t\t\tif (Math.round(Math.random())) {\r\n\t\t\t\t\tspawn_point.x += this.width;\r\n\t\t\t\t\tspawn_point.location = 'right';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tspawn_point.location = 'left';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn spawn_point;\r\n\t}\r\n\r\n\t/**\r\n\t * Check to see if this Emitter is destroyed\r\n\t */\r\n\tget isDestroyed() {\r\n\t\treturn this._destroyed;\r\n\t}\r\n\r\n\r\n\r\n\t/*********************************************************************************\r\n\t**  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t*********************************************************************************/\r\n\r\n\t/**\r\n\t * Update and remove particles based on the particles Time To Live (TTL)\r\n\t * @param {Number} elapsed_time\r\n\t */\r\n\t_updateParticles(elapsed_time) {\r\n\t\t// clear canvas if emitter is attached to a canvas element\r\n\t\tif (this.ctx) {\r\n\t\t\tthis.ctx.clearRect(0, 0, this.width, this.height);\r\n\t\t}\r\n\r\n\t\tfor (let i=0; i<this.particles.length; i++) {\r\n\t\t\tlet p = this.particles[i];\r\n\t\t\tp.update(elapsed_time);\r\n\r\n\t\t\t// call particles remove function to remove element from DOM then remove particle class from particle array\r\n\t\t\tif (p.TTL <= 0) {\r\n\t\t\t\tp.remove();\r\n\t\t\t\tthis.particles.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Create as many particles as the emit_delay & max_particles settings will allow\r\n\t * @param {Number} elapsed_time\r\n\t */\r\n\t_createParticles(elapsed_time) {\r\n\t\t// find the emitters exact position to spawn particles at for this update call (changes per update if random)\r\n\t\tvar spawn_point = this.particleSpawnPosition;\r\n\r\n\t\t// calculate the emit_delay amount for this update call (either a random amount between min/max or a standard number)\r\n\t\tvar delay_settings = this._settings.emit_delay;\r\n\t\tvar emit_delay = (delay_settings.min || delay_settings.max)?\r\n\t\t\t(Math.random() * (delay_settings.max - delay_settings.min)) + delay_settings.min:\r\n\t\t\tdelay_settings;\r\n\r\n\t\t// create as many particles as the delay & max particle count will allow based on time since last update\r\n\t\tif (this.particles.length < this._settings.max_particles) {\r\n\t\t\tthis._delay -= this._elapsed_time;\r\n\t\t\t// if emit_delay is 0, loop until all possible particles have been created\r\n\t\t\twhile (this._delay <= 0 && this.particles.length < this._settings.max_particles) {\r\n\t\t\t\tthis._delay += emit_delay;\r\n\r\n\t\t\t\t// create & append a particle at the given global spawn coordinates\r\n\t\t\t\tthis.addParticle(spawn_point);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n};\r\n","/*****************************************************************************************************/\r\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Description:  Particle System that controls Particle Emitters which in turn control Particles \t**/\r\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/*****************************************************************************************************/\r\n\r\n\r\n/**\r\n * ParticleSystem class, controls Emitters which in turn control Particles\r\n */\r\nclass ParticleSystem {\r\n\r\n\t/**\r\n\t * Creates a ParticleSystem object\r\n\t * @param {Object} cfg - default particle system settings\r\n \t * @deprecated {Number} cfg.timeout - time between update intervals for the particle system\r\n\t * @constructor\r\n \t */\r\n\tconstructor(cfg = {}, debug = false) {\r\n\t\t// setup default settings, given configuration\r\n\t\tthis._settings = $.extend(true, {\r\n\t\t\ttimeout: 30\r\n\t\t}, cfg);\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// for debugging purposes (used for console logging)\r\n\t\tthis._debug = debug;\r\n\r\n\t\t// particle system emitters\r\n\t\tthis._particle_emitters = [];\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// start a loop for the updating and rendering of emitters and particles\r\n\t\tif (window.requestAnimationFrame) {\r\n\t\t\tvar update = () => { window.setTimeout(() => { this._update(); window.requestAnimationFrame(update); }, this._settings.timeout); }\r\n\t\t\tupdate();\r\n\t\t} else {\r\n\t\t\twindow.setInterval(() => { this._update(); }, this._settings.timeout);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Add a particle emitter to the emitter list for updating/rendering purposes\r\n\t * @returns {class} Emitter - return a reference to emitter in case someone wants to chain function calls together\r\n\t */\r\n\taddEmitter(Emitter) {\r\n\t\tthis._particle_emitters.push(Emitter);\r\n\t\treturn Emitter;\r\n\t}\r\n\r\n\t/**\r\n\t * Remove emitter from the particle system\r\n\t * @param {class} Emitter\r\n\t */\r\n\tremoveEmitter(Emitter) {\r\n\t\tfor (let i=0; i<this._particle_emitters.length; i++) {\r\n\t\t\tif (Emitter == this._particle_emitters[i]) {\r\n\t\t\t\tthis._particle_emitters[i].remove();   \t\t// call the emitters remove function (which will call each particles remote function, among other things)\r\n\t\t\t\tthis._particle_emitters.splice(i, 1);  \t\t// remove this emitter from the particle system\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t/*********************************************************************************\r\n\t**  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t*********************************************************************************/\r\n\r\n\t/**\r\n\t * update each Particle Emitter contained within this Particle System\r\n\t */\r\n\t_update() {\r\n\t\tfor (let i=0; i<this._particle_emitters.length; i++) {\r\n\t\t\tlet Emitter = this._particle_emitters[i];\r\n\r\n\t\t\t// check if emitter is destroyed/removed, if so remove it from particle system (mostly just cleanup)\r\n\t\t\t// TODO:  Some day this \"destroy\" check would be better accomplished with an event listener\r\n\t\t\tif (Emitter.isDestroyed) {\r\n\t\t\t\tthis._particle_emitters.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t} else {\r\n\t\t\t\tEmitter.update();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n"]}