{"version":3,"sources":["particle-system.min.js","Particle.js","ParticleEmitter.js","ParticleSystem.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","Particle","spawn_point","direction","cfg","arguments","undefined","debug","this","_settings","$","extend","append_to","template","time_to_live","speed","size","$element","css","appendTo","width","height","local_coords","offsetParent","offset","coordinates","x","left","y","top","_debug","_vx","Math","cos","_vy","sin","_ttl","position","visibility","_render","value","elapsed_time","reduceTTL","move","remove","transform","get","ParticleEmitter","active","element","max_particles","emit_delay","min","max","particle","constructor","particles","outerWidth","outerHeight","_active","_destroyed","_triggerCallback","_spawn_position","_delay","_time","Date","_elapsed_time","getTime","radians","PI","now","console","log","_createParticles","_updateParticles","range","random","push","amount","callback","_this","window","setTimeout","call","clearTimeout","splice","p","update","TTL","particleSpawnPosition","delay_settings","addParticle","ParticleSystem","timeout","_particle_emitters","requestAnimationFrame","_update","setInterval","Emitter","isDestroyed"],"mappings":"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","file":"particle-system.min.js","sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*****************************************************************************************************/\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Description:  A Particle class for controlling how a single particle behaves\t\t\t\t\t**/\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/*****************************************************************************************************/\n\n/**\r\n * Particle class\r\n */\nvar Particle = function () {\n\n\t/**\r\n  * Create a Particle object\r\n  * @param {Object} spawn_point - x, y spawn point of particle\r\n  * @param {Number} spawn_point.x\r\n  * @param {Number} spawn_point.y\r\n  * @param {Number} direction - direction to move particle in radians\r\n  * @param {Object} cfg - default particle settings\r\n \t * @property {jQuery} cfg.append_to - element to append particles to\r\n \t * @property {String} cfg.template - an html string template to create particles with\r\n \t * @property {Number} cfg.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.speed - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.size - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n  * @constructor\r\n  */\n\tfunction Particle(spawn_point, direction) {\n\t\tvar cfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\tvar debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n\t\t_classCallCheck(this, Particle);\n\n\t\t// setup default settings, given configuration\n\t\tthis._settings = $.extend(true, {\n\t\t\tappend_to: $('body'),\n\t\t\ttemplate: '<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>',\n\t\t\ttime_to_live: 2000,\n\t\t\tspeed: 10,\n\t\t\tsize: 0\n\t\t}, cfg);\n\n\t\t// create a DOM object given a template, and hide so that it has dimension, but can't be seen until positioned\n\t\tthis.$element = $(this._settings.template).css('visibility', 'hidden');\n\n\t\t// append particle element to an element on the page\n\t\tthis.$element.appendTo(this._settings.append_to);\n\n\t\t// get width and height of element for positioning purposes\n\t\tthis.width = this.$element.width();\n\t\tthis.height = this.$element.height();\n\n\t\tthis.size = this._settings.size;\n\t\tthis.speed = this._settings.speed;\n\n\t\t// convert the global spawn_point coordinates into their appropriate local coordinates (based off the closest positioned parent)\n\t\tvar local_coords = this.$element.offsetParent().offset();\n\t\tthis.coordinates = { x: spawn_point.x - local_coords.left, y: spawn_point.y - local_coords.top };\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// for debugging purposes (used for console logging)\n\t\tthis._debug = debug;\n\n\t\t// OPTIMIZATION: velocity/movement amount based on speed and direction\n\t\tthis._vx = this.speed * Math.cos(direction);\n\t\tthis._vy = this.speed * -Math.sin(direction);\n\n\t\t// how long the particle will exist before it's removal\n\t\tthis._ttl = this._settings.time_to_live;\n\n\t\t/*********************************************************************************\r\n  **  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// set visibility so that the particle can now be seen (it was hidden until position calculations were complete)\n\t\tthis.$element.css({\n\t\t\t'position': 'absolute',\n\t\t\t'visibility': 'visible'\n\t\t});\n\n\t\t// render the particle\n\t\tthis._render();\n\t}\n\n\t_createClass(Particle, [{\n\t\tkey: 'update',\n\n\n\t\t/**\r\n   * @param {Number} elapsed_time - how long since the emitter/particle was last updated\r\n   */\n\t\tvalue: function update(elapsed_time) {\n\t\t\t// adjust particles time to live value (life time)\n\t\t\tthis.reduceTTL(elapsed_time);\n\n\t\t\t// adjust particles coordinates\n\t\t\tthis.move(elapsed_time);\n\n\t\t\t// adjust width & height based on size increase/decrease setting\n\t\t\tthis.width += this.size * elapsed_time;\n\t\t\tthis.height += this.size * elapsed_time;\n\n\t\t\t// render element (update in dom)\n\t\t\tthis._render();\n\t\t}\n\t}, {\n\t\tkey: 'reduceTTL',\n\n\n\t\t/**\r\n   * Reduce the particles life based on elapsed time\r\n   * @param elapsed_time\r\n   */\n\t\tvalue: function reduceTTL(elapsed_time) {\n\t\t\tthis._ttl -= elapsed_time;\n\t\t}\n\t}, {\n\t\tkey: 'move',\n\n\n\t\t/**\r\n   * Move particle based on speed, direction, and time since last update\r\n   * @param elapsed_time\r\n   */\n\t\tvalue: function move(elapsed_time) {\n\t\t\tthis.coordinates.x += this._vx * elapsed_time;\n\t\t\tthis.coordinates.y += this._vy * elapsed_time;\n\t\t}\n\t}, {\n\t\tkey: 'remove',\n\n\n\t\t/**\r\n   * Remove this particle element from the DOM\r\n   */\n\t\tvalue: function remove() {\n\t\t\tthis.$element.remove();\n\t\t}\n\t}, {\n\t\tkey: '_render',\n\n\n\t\t/**\r\n   * Render the particle in the dom\r\n   */\n\t\tvalue: function _render() {\n\t\t\t// TODO:  look into rendering to a canvas\n\t\t\tthis.$element.css({\n\t\t\t\t'top': 0,\n\t\t\t\t'left': 0,\n\t\t\t\t'transform': 'translate(' + (this.coordinates.x - this.height / 2) + 'px, ' + (this.coordinates.y - this.width / 2) + 'px)',\n\t\t\t\t'width': this.width + 'px',\n\t\t\t\t'height': this.height + 'px'\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'TTL',\n\n\n\t\t/**\r\n   * Get this particles remaining Time To Live\r\n   * @returns {Number}\r\n   */\n\t\tget: function get() {\n\t\t\treturn this._ttl;\n\t\t}\n\t}]);\n\n\treturn Particle;\n}();\n\n;\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*****************************************************************************************************/\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Description:  Particle Emitters which creates & updates Particles \t\t\t\t\t\t\t\t**/\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/*****************************************************************************************************/\n\n/**\r\n * ParticleEmitter class, controls Particles\r\n */\nvar ParticleEmitter = function () {\n\n\t/**\r\n  * Creates a ParticleEmitter object with the given configuration.  Note that the settings should not be changed dynamically,\r\n  *  \tas there are some optimization that causes some of the initial configuration settings to become stale.  Changing these\r\n  *  \tsettings after the emitter is initialized, would have unintended results.\r\n  * @param {Object} cfg - default settings for emitter\r\n  * @property {jQuery} cfg.element - jquery element to calculate spawn location\r\n \t * @property {Boolean} cfg.active - status of emitter when intiailized (on/off)\r\n \t * @property {Number} cfg.max_particles - max number of particle the emitter can hold\r\n \t * @property {Object|Number} cfg.emit_delay - random time between particle emissions or a single constant value\r\n \t * @property {Number} cfg.emit_delay.min\r\n \t * @property {Number} cfg.emit_delay.max\r\n \t * @property {Object} cfg.direction - random direction range to move particles\r\n \t * @property {Number} cfg.direction.min - min range in degrees (0 moves up, 90 right, 180 down, 270 left)\r\n \t * @property {Number} cfg.direction.max - max range in degrees (360 moves up)\r\n  * @property {String} cfg.spawn_point - particle spawn location within emitter element ('center', 'random', null for top-left corner of element)\r\n \t * @property {Object} cfg.particle - default particle settings\r\n \t * @property {Class} cfg.particle.constructor - reference to class (Ex: Particle)\r\n \t * @property {jQuery} cfg.particle.append_to - element to append particles to\r\n \t * @property {String} cfg.particle.template - an html string template to create particles with\r\n \t * @property {Number} cfg.particle.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.particle.speed - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.particle.size - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n  * @constructor\r\n  */\n\tfunction ParticleEmitter() {\n\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\tvar debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t_classCallCheck(this, ParticleEmitter);\n\n\t\t// setup default settings, given configuration\n\t\tthis._settings = $.extend(true, {\n\t\t\tactive: false,\n\t\t\telement: $('body'),\n\t\t\tmax_particles: 100,\n\t\t\temit_delay: { min: 100, max: 100 },\n\t\t\tdirection: { min: 0, max: 360 },\n\t\t\tspawn_point: 'center',\n\n\t\t\tparticle: {\n\t\t\t\tconstructor: Particle,\n\t\t\t\tappend_to: $('body'),\n\t\t\t\ttemplate: '<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>',\n\t\t\t\ttime_to_live: 2000,\n\t\t\t\tspeed: 70,\n\t\t\t\tsize: 0\n\t\t\t}\n\t\t}, cfg);\n\n\t\t// array of particles\n\t\tthis.particles = [];\n\n\t\t// dom jquery reference to emitter element\n\t\tthis.$element = this._settings.element;\n\n\t\t// width & height for calculating spawn location within dom $element\n\t\tthis.width = this.$element.outerWidth();\n\t\tthis.height = this.$element.outerHeight();\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// for debugging purposes (used for console logging)\n\t\tthis._debug = debug;\n\n\t\t// whether or not this emitter is actively emitting particles\n\t\tthis._active = this._settings.active;\n\n\t\t// whether or not this emitter has been destroyed/removed\n\t\tthis._destroyed = false;\n\n\t\t// remember timeout for trigger callback (to clear when toggling)\n\t\tthis._triggerCallback = null;\n\n\t\t// initial spawn point offset and position of emitter\n\t\tthis._spawn_position = {};\n\n\t\t// total delay amount\n\t\tthis._delay = 0;\n\n\t\t// elapsed time\n\t\tthis._time = new Date();\n\t\tthis._elapsed_time = this._time.getTime();\n\n\t\t// OPTIMIZATION: convert direction in degrees to radians (in degree's initially b/c those are easier for people to understand, but radians are required)\n\t\t//\t\t\t\t\talso subtract 90 degree's so that 0 is aimed upwards, b/c that too makes more sense\n\t\tvar radians = -Math.PI / 180;\n\t\tthis._settings.direction.min = (this._settings.direction.min - 90) * radians;\n\t\tthis._settings.direction.max = (this._settings.direction.max - 90) * radians;\n\n\t\t// OPTIMIZATION: adjust speed & size from seconds to milliseconds (again, seconds are easier to understand than milliseconds, but milliseconds are required)\n\t\tif (this._settings.particle.speed > 0) {\n\t\t\tthis._settings.particle.speed /= 1000;\n\t\t}\n\t\tif (this._settings.particle.size > 0) {\n\t\t\tthis._settings.particle.size /= 1000;\n\t\t}\n\n\t\t// OPTIMIZATION: create a spawn point relative to the $element (\"center\" and default \"null\" here as an optimization, \"random\" is handled below inside particleSpawnPosition)\n\t\tthis._spawn_position = {\n\t\t\tx: this._settings.spawn_point == 'center' ? this.width / 2 : 0,\n\t\t\ty: this._settings.spawn_point == 'center' ? this.height / 2 : 0\n\t\t};\n\t}\n\n\t/**\r\n  * update emitter by updating, adding, and removing particles\r\n  */\n\n\n\t_createClass(ParticleEmitter, [{\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\t\t\t// calculate time since last update\n\t\t\tvar now = new Date();\n\t\t\tthis._elapsed_time = now - this._time;\n\n\t\t\t// a cap for elapsed time for slower computers, b/c if you don't, you end up not even seeing any particles as the screen updates too slowly\n\t\t\t// the idea is that I'd rather see slow moving particles, than none at all\n\t\t\tif (this._elapsed_time > 500) {\n\t\t\t\t// TODO: instead of capping elapsed time, find a way to pre-calculate/optimize for the computer in question (by removing particles, capping max particle count, and/or increasing time between emissions)\n\t\t\t\tif (this._debug) {\n\t\t\t\t\tconsole.log('Particle System: Capping elapsed time at 500 (was ' + this._elapsed_time + ')');\n\t\t\t\t}\n\t\t\t\tthis._elapsed_time = 500;\n\t\t\t}\n\n\t\t\t// only create particles if emitter is set to active\n\t\t\tif (this._active) {\n\t\t\t\tthis._createParticles(this._elapsed_time);\n\t\t\t}\n\n\t\t\t// update & remove particles by telling them how much time as passed since the last update\n\t\t\tthis._updateParticles(this._elapsed_time);\n\n\t\t\t// reset elapsed time to the current time after all updates have occured\n\t\t\tthis._time = new Date().getTime();\n\t\t}\n\n\t\t/**\r\n   * Create & append a particle given spawn_point and direction\r\n   * @param {Object} spawn_point - global coordinates to create particle at\r\n   * @param {Number} spawn_point.x\r\n   * @param {Number} spawn_point.y\r\n   * @param {Number} [direction] - direction in degrees, for particle to move\r\n   */\n\n\t}, {\n\t\tkey: 'addParticle',\n\t\tvalue: function addParticle(spawn_point) {\n\t\t\tvar direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\t// if no direction was given, create a random direction based on settings\n\t\t\tif (!direction) {\n\t\t\t\tvar range = this._settings.direction.max - this._settings.direction.min;\n\t\t\t\tdirection = Math.random() * range + this._settings.direction.min;\n\t\t\t}\n\n\t\t\t// create a particle and append it to list\n\t\t\tthis.particles.push(new this._settings.particle.constructor(spawn_point, direction, this._settings.particle, this._debug));\n\t\t}\n\n\t\t/**\r\n   * Trigger this emitter for x amount of time\r\n   * @param {Number} amount - how long to emit particles for\r\n   * @param {Function|Callback} [callback] - optional function to call when completed\r\n   */\n\n\t}, {\n\t\tkey: 'trigger',\n\t\tvalue: function trigger(amount, callback) {\n\t\t\tvar _this = this;\n\n\t\t\t// set this emitter to active state\n\t\t\tthis._active = true;\n\n\t\t\t// setup a delay callback to disable the emitter\n\t\t\tthis._triggerCallback = window.setTimeout(function () {\n\t\t\t\t_this._active = false;\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call();\n\t\t\t\t}\n\t\t\t}, amount);\n\t\t}\n\n\t\t/**\r\n   * Toggle emitter on/off\r\n   */\n\n\t}, {\n\t\tkey: 'toggle',\n\t\tvalue: function toggle() {\n\t\t\t// toggle boolean activate status\n\t\t\tthis._active = !this._active;\n\n\t\t\t// clear trigger function's callback, so that toggle and trigger don't conflict as much\n\t\t\tif (this._triggerCallback) {\n\t\t\t\twindow.clearTimeout(this._triggerCallback);\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Turn emitter on\r\n   */\n\n\t}, {\n\t\tkey: 'activate',\n\t\tvalue: function activate() {\n\t\t\tthis._active = true;\n\t\t}\n\n\t\t/**\r\n   * Turn emitter off\r\n   */\n\n\t}, {\n\t\tkey: 'deactivate',\n\t\tvalue: function deactivate() {\n\t\t\tthis._active = false;\n\t\t}\n\n\t\t/**\r\n   * Call particles remove function and then remove particle from array\r\n   */\n\n\t}, {\n\t\tkey: 'remove',\n\t\tvalue: function remove() {\n\t\t\tthis._destroyed = true;\n\t\t\tfor (var i = 0; i < this.particles.length; i++) {\n\t\t\t\tthis.particles[i].remove();\n\t\t\t\tthis.particles.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Calculate & Return the global spawn position of particle\r\n   * @returns {x: number, y: number}\r\n   */\n\n\t}, {\n\t\tkey: '_updateParticles',\n\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t/**\r\n   * Update and remove particles based on the particles Time To Live (TTL)\r\n   * @param {Number} elapsed_time\r\n   */\n\t\tvalue: function _updateParticles(elapsed_time) {\n\t\t\tfor (var i = 0; i < this.particles.length; i++) {\n\t\t\t\tvar p = this.particles[i];\n\t\t\t\tp.update(elapsed_time);\n\n\t\t\t\t// call particles remove function to remove element from DOM then remove particle class from particle array\n\t\t\t\tif (p.TTL <= 0) {\n\t\t\t\t\tp.remove();\n\t\t\t\t\tthis.particles.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * Create as many particles as the emit_delay & max_particles settings will allow\r\n   * @param {Number} elapsed_time\r\n   */\n\n\t}, {\n\t\tkey: '_createParticles',\n\t\tvalue: function _createParticles(elapsed_time) {\n\t\t\t// find the emitters exact position to spawn particles at for this update call (changes per update if random)\n\t\t\tvar spawn_point = this.particleSpawnPosition;\n\n\t\t\t// calculate the emit_delay amount for this update call (either a random amount between min/max or a standard number)\n\t\t\tvar delay_settings = this._settings.emit_delay;\n\t\t\tvar emit_delay = delay_settings.min || delay_settings.max ? Math.random() * (delay_settings.max - delay_settings.min) + delay_settings.min : delay_settings;\n\n\t\t\t// create as many particles as the delay & max particle count will allow based on time since last update\n\t\t\tif (this.particles.length < this._settings.max_particles) {\n\t\t\t\tthis._delay -= this._elapsed_time;\n\t\t\t\t// if emit_delay is 0, loop until all possible particles have been created\n\t\t\t\twhile (this._delay <= 0 && this.particles.length < this._settings.max_particles) {\n\t\t\t\t\tthis._delay += emit_delay;\n\n\t\t\t\t\t// create & append a particle at the given global spawn coordinates\n\t\t\t\t\tthis.addParticle(spawn_point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'particleSpawnPosition',\n\t\tget: function get() {\n\t\t\tvar offset = this.$element.offset();\n\t\t\tvar spawn_point = { x: offset.left + this._spawn_position.x, y: offset.top + this._spawn_position.y };\n\n\t\t\tif (this._settings.spawn_point == 'random') {\n\t\t\t\tspawn_point.x += Math.random() * this.width;\n\t\t\t\tspawn_point.y += Math.random() * this.height;\n\t\t\t}\n\n\t\t\treturn spawn_point;\n\t\t}\n\n\t\t/**\r\n   * Check to see if this Emitter is destroyed\r\n   */\n\n\t}, {\n\t\tkey: 'isDestroyed',\n\t\tget: function get() {\n\t\t\treturn this._destroyed;\n\t\t}\n\t}]);\n\n\treturn ParticleEmitter;\n}();\n\n;\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*****************************************************************************************************/\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Description:  Particle System that controls Particle Emitters which in turn control Particles \t**/\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\n/*****************************************************************************************************/\n\n/**\r\n * ParticleSystem class, controls Emitters which in turn control Particles\r\n */\nvar ParticleSystem = function () {\n\n\t/**\r\n  * Creates a ParticleSystem object\r\n  * @param {Object} cfg - default particle system settings\r\n \t * @deprecated {Number} cfg.timeout - time between update intervals for the particle system\r\n  * @constructor\r\n \t */\n\tfunction ParticleSystem() {\n\t\tvar _this = this;\n\n\t\tvar cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\tvar debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\t\t_classCallCheck(this, ParticleSystem);\n\n\t\t// setup default settings, given configuration\n\t\tthis._settings = $.extend(true, {\n\t\t\ttimeout: 30\n\t\t}, cfg);\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// for debugging purposes (used for console logging)\n\t\tthis._debug = debug;\n\n\t\t// particle system emitters\n\t\tthis._particle_emitters = [];\n\n\t\t/*********************************************************************************\r\n  **  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t// start a loop for the updating and rendering of emitters and particles\n\t\tif (requestAnimationFrame) {\n\t\t\tvar update = function update() {\n\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\t_this._update();requestAnimationFrame(update);\n\t\t\t\t}, _this._settings.timeout);\n\t\t\t};\n\t\t\tupdate();\n\t\t} else {\n\t\t\twindow.setInterval(function () {\n\t\t\t\t_this._update();\n\t\t\t}, this._settings.timeout);\n\t\t}\n\t}\n\n\t/**\r\n  * Add a particle emitter to the emitter list for updating/rendering purposes\r\n  * @returns {class} Emitter - return a reference to emitter in case someone wants to chain function calls together\r\n  */\n\n\n\t_createClass(ParticleSystem, [{\n\t\tkey: \"addEmitter\",\n\t\tvalue: function addEmitter(Emitter) {\n\t\t\tthis._particle_emitters.push(Emitter);\n\t\t\treturn Emitter;\n\t\t}\n\n\t\t/**\r\n   * Remove emitter from the particle system\r\n   * @param {class} Emitter\r\n   */\n\n\t}, {\n\t\tkey: \"removeEmitter\",\n\t\tvalue: function removeEmitter(Emitter) {\n\t\t\tfor (var i = 0; i < this._particle_emitters.length; i++) {\n\t\t\t\tif (Emitter == this._particle_emitters[i]) {\n\t\t\t\t\tthis._particle_emitters[i].remove(); // call the emitters remove function (which will call each particles remote function, among other things)\n\t\t\t\t\tthis._particle_emitters.splice(i, 1); // remove this emitter from the particle system\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*********************************************************************************\r\n  **  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n  *********************************************************************************/\n\n\t\t/**\r\n   * update each Particle Emitter contained within this Particle System\r\n   */\n\n\t}, {\n\t\tkey: \"_update\",\n\t\tvalue: function _update() {\n\t\t\tfor (var i = 0; i < this._particle_emitters.length; i++) {\n\t\t\t\tvar Emitter = this._particle_emitters[i];\n\n\t\t\t\t// check if emitter is destroyed/removed, if so remove it from particle system (mostly just cleanup)\n\t\t\t\t// TODO:  Some day this \"destroy\" check would be better accomplished with an event listener\n\t\t\t\tif (Emitter.isDestroyed) {\n\t\t\t\t\tthis._particle_emitters.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t} else {\n\t\t\t\t\tEmitter.update();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn ParticleSystem;\n}();\n\n;","/*****************************************************************************************************/\r\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Description:  A Particle class for controlling how a single particle behaves\t\t\t\t\t**/\r\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/*****************************************************************************************************/\r\n\r\n\r\n/**\r\n * Particle class\r\n */\r\nclass Particle {\r\n\r\n\t/**\r\n\t * Create a Particle object\r\n\t * @param {Object} spawn_point - x, y spawn point of particle\r\n\t * @param {Number} spawn_point.x\r\n\t * @param {Number} spawn_point.y\r\n\t * @param {Number} direction - direction to move particle in radians\r\n\t * @param {Object} cfg - default particle settings\r\n \t * @property {jQuery} cfg.append_to - element to append particles to\r\n \t * @property {String} cfg.template - an html string template to create particles with\r\n \t * @property {Number} cfg.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.speed - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.size - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n\t * @constructor\r\n\t */\r\n\tconstructor(spawn_point, direction, cfg = {}, debug = false) {\r\n\t\t// setup default settings, given configuration\r\n\t\tthis._settings = $.extend(true, {\r\n\t\t\tappend_to: $('body'),\r\n\t\t\ttemplate: `<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>`,\r\n\t\t\ttime_to_live: 2000,\r\n\t\t\tspeed: 10,\r\n\t\t\tsize: 0\r\n\t\t}, cfg);\r\n\r\n\t\t// create a DOM object given a template, and hide so that it has dimension, but can't be seen until positioned\r\n\t\tthis.$element = $(this._settings.template).css('visibility', 'hidden');\r\n\r\n\t\t// append particle element to an element on the page\r\n\t\tthis.$element.appendTo(this._settings.append_to);\r\n\r\n\t\t// get width and height of element for positioning purposes\r\n\t\tthis.width = this.$element.width();\r\n\t\tthis.height = this.$element.height();\r\n\r\n\t\tthis.size = this._settings.size;\r\n\t\tthis.speed = this._settings.speed;\r\n\r\n\t\t// convert the global spawn_point coordinates into their appropriate local coordinates (based off the closest positioned parent)\r\n\t\tvar local_coords = this.$element.offsetParent().offset();\r\n\t\tthis.coordinates = {x: spawn_point.x - local_coords.left, y: spawn_point.y - local_coords.top};\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// for debugging purposes (used for console logging)\r\n\t\tthis._debug = debug;\r\n\r\n\t\t// OPTIMIZATION: velocity/movement amount based on speed and direction\r\n\t\tthis._vx = this.speed * (Math.cos(direction));\r\n\t\tthis._vy = this.speed * (-Math.sin(direction));\r\n\r\n\t\t// how long the particle will exist before it's removal\r\n\t\tthis._ttl = this._settings.time_to_live;\r\n\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// set visibility so that the particle can now be seen (it was hidden until position calculations were complete)\r\n\t\tthis.$element.css({\r\n\t\t\t'position': 'absolute',\r\n\t\t\t'visibility': 'visible'\r\n\t\t});\r\n\r\n\t\t// render the particle\r\n\t\tthis._render();\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @param {Number} elapsed_time - how long since the emitter/particle was last updated\r\n\t */\r\n\tupdate(elapsed_time) {\r\n\t\t// adjust particles time to live value (life time)\r\n\t\tthis.reduceTTL(elapsed_time);\r\n\r\n\t\t// adjust particles coordinates\r\n\t\tthis.move(elapsed_time);\r\n\r\n\t\t// adjust width & height based on size increase/decrease setting\r\n\t\tthis.width += this.size * elapsed_time;\r\n\t\tthis.height += this.size * elapsed_time;\r\n\r\n\t\t// render element (update in dom)\r\n\t\tthis._render();\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Reduce the particles life based on elapsed time\r\n\t * @param elapsed_time\r\n\t */\r\n\treduceTTL(elapsed_time) {\r\n\t\tthis._ttl -= elapsed_time;\r\n\t};\r\n\r\n\t/**\r\n\t * Move particle based on speed, direction, and time since last update\r\n\t * @param elapsed_time\r\n\t */\r\n\tmove(elapsed_time) {\r\n\t\tthis.coordinates.x += this._vx * elapsed_time;\r\n\t\tthis.coordinates.y += this._vy * elapsed_time;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove this particle element from the DOM\r\n\t */\r\n\tremove() {\r\n\t\tthis.$element.remove();\r\n\t};\r\n\r\n\t/**\r\n\t * Get this particles remaining Time To Live\r\n\t * @returns {Number}\r\n\t */\r\n\tget TTL() {\r\n\t\treturn this._ttl;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Render the particle in the dom\r\n\t */\r\n\t _render() {\r\n\t\t// TODO:  look into rendering to a canvas\r\n \t\tthis.$element.css({\r\n \t\t\t'top': 0,\r\n \t\t\t'left': 0,\r\n \t\t\t'transform': 'translate(' + (this.coordinates.x - (this.height / 2)) + 'px, ' + (this.coordinates.y - (this.width / 2)) + 'px)',\r\n \t\t\t'width': this.width + 'px',\r\n \t\t\t'height': this.height + 'px'\r\n \t\t});\r\n \t};\r\n};\r\n","/*****************************************************************************************************/\r\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Description:  Particle Emitters which creates & updates Particles \t\t\t\t\t\t\t\t**/\r\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/*****************************************************************************************************/\r\n\r\n\r\n/**\r\n * ParticleEmitter class, controls Particles\r\n */\r\nclass ParticleEmitter {\r\n\r\n\t/**\r\n\t * Creates a ParticleEmitter object with the given configuration.  Note that the settings should not be changed dynamically,\r\n\t *  \tas there are some optimization that causes some of the initial configuration settings to become stale.  Changing these\r\n\t *  \tsettings after the emitter is initialized, would have unintended results.\r\n\t * @param {Object} cfg - default settings for emitter\r\n\t * @property {jQuery} cfg.element - jquery element to calculate spawn location\r\n \t * @property {Boolean} cfg.active - status of emitter when intiailized (on/off)\r\n \t * @property {Number} cfg.max_particles - max number of particle the emitter can hold\r\n \t * @property {Object|Number} cfg.emit_delay - random time between particle emissions or a single constant value\r\n \t * @property {Number} cfg.emit_delay.min\r\n \t * @property {Number} cfg.emit_delay.max\r\n \t * @property {Object} cfg.direction - random direction range to move particles\r\n \t * @property {Number} cfg.direction.min - min range in degrees (0 moves up, 90 right, 180 down, 270 left)\r\n \t * @property {Number} cfg.direction.max - max range in degrees (360 moves up)\r\n\t * @property {String} cfg.spawn_point - particle spawn location within emitter element ('center', 'random', null for top-left corner of element)\r\n \t * @property {Object} cfg.particle - default particle settings\r\n \t * @property {Class} cfg.particle.constructor - reference to class (Ex: Particle)\r\n \t * @property {jQuery} cfg.particle.append_to - element to append particles to\r\n \t * @property {String} cfg.particle.template - an html string template to create particles with\r\n \t * @property {Number} cfg.particle.time_to_live - lifespan of particles (how long they'll exist before being removed)\r\n \t * @property {Number} cfg.particle.speed - how fast particles will move based on elapsed time in pps (pixels per second)\r\n \t * @property {Number} cfg.particle.size - number to incrementally increase particle element by, based on elapsed time in pps (pixels per second)\r\n\t * @constructor\r\n\t */\r\n\tconstructor(cfg = {}, debug = false) {\r\n\t\t// setup default settings, given configuration\r\n\t\tthis._settings = $.extend(true, {\r\n\t\t\tactive: false,\r\n\t\t\telement: $('body'),\r\n\t\t\tmax_particles: 100,\r\n\t\t\temit_delay: { min: 100, max: 100 },\r\n\t\t\tdirection: { min: 0, max: 360 },\r\n\t\t\tspawn_point: 'center',\r\n\r\n\t\t\tparticle: {\r\n\t\t\t\tconstructor: Particle,\r\n\t\t\t\tappend_to: $('body'),\r\n\t\t\t\ttemplate: `<div style=\"width: 5px; height: 5px; background-color: red; z-index: 2;\"></div>`,\r\n\t\t\t\ttime_to_live: 2000,\r\n\t\t\t\tspeed: 70,\r\n\t\t\t\tsize: 0\r\n\t\t\t}\r\n\t\t}, cfg);\r\n\r\n\t\t// array of particles\r\n\t\tthis.particles = [];\r\n\r\n\t\t// dom jquery reference to emitter element\r\n\t\tthis.$element = this._settings.element;\r\n\r\n\t\t// width & height for calculating spawn location within dom $element\r\n\t\tthis.width = this.$element.outerWidth();\r\n\t\tthis.height = this.$element.outerHeight();\r\n\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// for debugging purposes (used for console logging)\r\n\t\tthis._debug = debug;\r\n\r\n \t\t// whether or not this emitter is actively emitting particles\r\n \t\tthis._active = this._settings.active;\r\n\r\n\t\t// whether or not this emitter has been destroyed/removed\r\n\t\tthis._destroyed = false;\r\n\r\n\t\t // remember timeout for trigger callback (to clear when toggling)\r\n\t\tthis._triggerCallback = null;\r\n\r\n\t\t// initial spawn point offset and position of emitter\r\n\t\tthis._spawn_position = {};\r\n\r\n\t\t// total delay amount\r\n\t\tthis._delay = 0;\r\n\r\n\t\t// elapsed time\r\n\t\tthis._time = new Date();\r\n\t\tthis._elapsed_time = this._time.getTime();\r\n\r\n\r\n\t\t// OPTIMIZATION: convert direction in degrees to radians (in degree's initially b/c those are easier for people to understand, but radians are required)\r\n\t\t//\t\t\t\t\talso subtract 90 degree's so that 0 is aimed upwards, b/c that too makes more sense\r\n\t\tvar radians = -Math.PI / 180;\r\n\t\tthis._settings.direction.min = (this._settings.direction.min - 90) * radians;\r\n\t\tthis._settings.direction.max = (this._settings.direction.max - 90) * radians;\r\n\r\n\t\t// OPTIMIZATION: adjust speed & size from seconds to milliseconds (again, seconds are easier to understand than milliseconds, but milliseconds are required)\r\n\t\tif (this._settings.particle.speed > 0) { this._settings.particle.speed /= 1000; }\r\n\t\tif (this._settings.particle.size > 0) { this._settings.particle.size /= 1000; }\r\n\r\n\t\t// OPTIMIZATION: create a spawn point relative to the $element (\"center\" and default \"null\" here as an optimization, \"random\" is handled below inside particleSpawnPosition)\r\n\t\tthis._spawn_position = {\r\n\t\t\tx: (this._settings.spawn_point == 'center')? (this.width / 2): 0,\r\n\t\t\ty: (this._settings.spawn_point == 'center')? (this.height / 2): 0\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * update emitter by updating, adding, and removing particles\r\n\t */\r\n\tupdate() {\r\n\t\t// calculate time since last update\r\n\t\tvar now = new Date();\r\n\t\tthis._elapsed_time = now - this._time;\r\n\r\n\t\t// a cap for elapsed time for slower computers, b/c if you don't, you end up not even seeing any particles as the screen updates too slowly\r\n\t\t// the idea is that I'd rather see slow moving particles, than none at all\r\n\t\tif (this._elapsed_time > 500) {\r\n\t\t\t// TODO: instead of capping elapsed time, find a way to pre-calculate/optimize for the computer in question (by removing particles, capping max particle count, and/or increasing time between emissions)\r\n\t\t\tif (this._debug) { console.log('Particle System: Capping elapsed time at 500 (was '+this._elapsed_time+')'); }\r\n\t\t\tthis._elapsed_time = 500;\r\n\t\t}\r\n\r\n\t\t// only create particles if emitter is set to active\r\n\t\tif (this._active) {\r\n\t\t\tthis._createParticles(this._elapsed_time);\r\n\t\t}\r\n\r\n\t\t// update & remove particles by telling them how much time as passed since the last update\r\n\t\tthis._updateParticles(this._elapsed_time);\r\n\r\n\t\t// reset elapsed time to the current time after all updates have occured\r\n\t\tthis._time = (new Date()).getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * Create & append a particle given spawn_point and direction\r\n\t * @param {Object} spawn_point - global coordinates to create particle at\r\n\t * @param {Number} spawn_point.x\r\n\t * @param {Number} spawn_point.y\r\n\t * @param {Number} [direction] - direction in degrees, for particle to move\r\n\t */\r\n\taddParticle(spawn_point, direction = null) {\r\n\t\t// if no direction was given, create a random direction based on settings\r\n\t\tif (!direction) {\r\n\t\t\tvar range = this._settings.direction.max - this._settings.direction.min;\r\n\t\t\tdirection = (Math.random() * range) + this._settings.direction.min;\r\n\t\t}\r\n\r\n\t\t// create a particle and append it to list\r\n\t\tthis.particles.push(new this._settings.particle.constructor(spawn_point, direction, this._settings.particle, this._debug));\r\n\t}\r\n\r\n\t/**\r\n\t * Trigger this emitter for x amount of time\r\n\t * @param {Number} amount - how long to emit particles for\r\n\t * @param {Function|Callback} [callback] - optional function to call when completed\r\n\t */\r\n\ttrigger(amount, callback) {\r\n\t\t// set this emitter to active state\r\n\t\tthis._active = true;\r\n\r\n\t\t// setup a delay callback to disable the emitter\r\n\t\tthis._triggerCallback = window.setTimeout(() => {\r\n\t\t\tthis._active = false;\r\n\t\t\tif (callback) { callback.call(); }\r\n\t\t}, amount);\r\n\t}\r\n\r\n\t/**\r\n\t * Toggle emitter on/off\r\n\t */\r\n\ttoggle() {\r\n\t\t// toggle boolean activate status\r\n\t\tthis._active = !this._active;\r\n\r\n\t\t// clear trigger function's callback, so that toggle and trigger don't conflict as much\r\n\t\tif (this._triggerCallback) { window.clearTimeout(this._triggerCallback); }\r\n\t}\r\n\r\n\t/**\r\n\t * Turn emitter on\r\n\t */\r\n\tactivate() {\r\n\t\tthis._active = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Turn emitter off\r\n\t */\r\n\tdeactivate() {\r\n\t\tthis._active = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Call particles remove function and then remove particle from array\r\n\t */\r\n\tremove() {\r\n\t\tthis._destroyed = true;\r\n\t\tfor (let i=0; i<this.particles.length; i++) {\r\n\t\t\tthis.particles[i].remove();\r\n\t\t\tthis.particles.splice(i, 1);\r\n\t\t\ti--;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate & Return the global spawn position of particle\r\n\t * @returns {x: number, y: number}\r\n\t */\r\n\tget particleSpawnPosition() {\r\n\t\tvar offset = this.$element.offset();\r\n\t\tvar spawn_point = {x: offset.left + this._spawn_position.x, y: offset.top + this._spawn_position.y};\r\n\r\n\t\tif (this._settings.spawn_point == 'random') {\r\n\t\t\tspawn_point.x += Math.random() * this.width;\r\n\t\t\tspawn_point.y += Math.random() * this.height;\r\n\t\t}\r\n\r\n\t\treturn spawn_point;\r\n\t}\r\n\r\n\t/**\r\n\t * Check to see if this Emitter is destroyed\r\n\t */\r\n\tget isDestroyed() {\r\n\t\treturn this._destroyed;\r\n\t}\r\n\r\n\r\n\r\n\t/*********************************************************************************\r\n\t**  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t*********************************************************************************/\r\n\r\n\t/**\r\n\t * Update and remove particles based on the particles Time To Live (TTL)\r\n\t * @param {Number} elapsed_time\r\n\t */\r\n\t_updateParticles(elapsed_time) {\r\n\t\tfor (let i=0; i<this.particles.length; i++) {\r\n\t\t\tlet p = this.particles[i];\r\n\t\t\tp.update(elapsed_time);\r\n\r\n\t\t\t// call particles remove function to remove element from DOM then remove particle class from particle array\r\n\t\t\tif (p.TTL <= 0) {\r\n\t\t\t\tp.remove();\r\n\t\t\t\tthis.particles.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Create as many particles as the emit_delay & max_particles settings will allow\r\n\t * @param {Number} elapsed_time\r\n\t */\r\n\t_createParticles(elapsed_time) {\r\n\t\t// find the emitters exact position to spawn particles at for this update call (changes per update if random)\r\n\t\tvar spawn_point = this.particleSpawnPosition;\r\n\r\n\t\t// calculate the emit_delay amount for this update call (either a random amount between min/max or a standard number)\r\n\t\tvar delay_settings = this._settings.emit_delay;\r\n\t\tvar emit_delay = (delay_settings.min || delay_settings.max)?\r\n\t\t\t(Math.random() * (delay_settings.max - delay_settings.min)) + delay_settings.min:\r\n\t\t\tdelay_settings;\r\n\r\n\t\t// create as many particles as the delay & max particle count will allow based on time since last update\r\n\t\tif (this.particles.length < this._settings.max_particles) {\r\n\t\t\tthis._delay -= this._elapsed_time;\r\n\t\t\t// if emit_delay is 0, loop until all possible particles have been created\r\n\t\t\twhile (this._delay <= 0 && this.particles.length < this._settings.max_particles) {\r\n\t\t\t\tthis._delay += emit_delay;\r\n\r\n\t\t\t\t// create & append a particle at the given global spawn coordinates\r\n\t\t\t\tthis.addParticle(spawn_point);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n};\r\n","/*****************************************************************************************************/\r\n/**  Author: Chris A Vaccarello\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Description:  Particle System that controls Particle Emitters which in turn control Particles \t**/\r\n/**  Date: 6/16/16\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/**  Compatibility: FF, Chrome, Edge, IE10+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**/\r\n/*****************************************************************************************************/\r\n\r\n\r\n/**\r\n * ParticleSystem class, controls Emitters which in turn control Particles\r\n */\r\nclass ParticleSystem {\r\n\r\n\t/**\r\n\t * Creates a ParticleSystem object\r\n\t * @param {Object} cfg - default particle system settings\r\n \t * @deprecated {Number} cfg.timeout - time between update intervals for the particle system\r\n\t * @constructor\r\n \t */\r\n\tconstructor(cfg = {}, debug = false) {\r\n\t\t// setup default settings, given configuration\r\n\t\tthis._settings = $.extend(true, {\r\n\t\t\ttimeout: 30\r\n\t\t}, cfg);\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  PRIVATE VARIABLES\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// for debugging purposes (used for console logging)\r\n\t\tthis._debug = debug;\r\n\r\n\t\t// particle system emitters\r\n\t\tthis._particle_emitters = [];\r\n\r\n\r\n\t\t/*********************************************************************************\r\n\t\t**  INITIALIZE PARTICLE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t\t*********************************************************************************/\r\n\r\n\t\t// start a loop for the updating and rendering of emitters and particles\r\n\t\tif (requestAnimationFrame) {\r\n\t\t\tvar update = () => { window.setTimeout(() => { this._update(); requestAnimationFrame(update); }, this._settings.timeout); }\r\n\t\t\tupdate();\r\n\t\t} else {\r\n\t\t\twindow.setInterval(() => { this._update(); }, this._settings.timeout);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Add a particle emitter to the emitter list for updating/rendering purposes\r\n\t * @returns {class} Emitter - return a reference to emitter in case someone wants to chain function calls together\r\n\t */\r\n\taddEmitter(Emitter) {\r\n\t\tthis._particle_emitters.push(Emitter);\r\n\t\treturn Emitter;\r\n\t}\r\n\r\n\t/**\r\n\t * Remove emitter from the particle system\r\n\t * @param {class} Emitter\r\n\t */\r\n\tremoveEmitter(Emitter) {\r\n\t\tfor (let i=0; i<this._particle_emitters.length; i++) {\r\n\t\t\tif (Emitter == this._particle_emitters[i]) {\r\n\t\t\t\tthis._particle_emitters[i].remove();   \t\t// call the emitters remove function (which will call each particles remote function, among other things)\r\n\t\t\t\tthis._particle_emitters.splice(i, 1);  \t\t// remove this emitter from the particle system\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\t/*********************************************************************************\r\n\t**  PRIVATE METHODS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t**\r\n\t*********************************************************************************/\r\n\r\n\t/**\r\n\t * update each Particle Emitter contained within this Particle System\r\n\t */\r\n\t_update() {\r\n\t\tfor (let i=0; i<this._particle_emitters.length; i++) {\r\n\t\t\tlet Emitter = this._particle_emitters[i];\r\n\r\n\t\t\t// check if emitter is destroyed/removed, if so remove it from particle system (mostly just cleanup)\r\n\t\t\t// TODO:  Some day this \"destroy\" check would be better accomplished with an event listener\r\n\t\t\tif (Emitter.isDestroyed) {\r\n\t\t\t\tthis._particle_emitters.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t} else {\r\n\t\t\t\tEmitter.update();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n"]}